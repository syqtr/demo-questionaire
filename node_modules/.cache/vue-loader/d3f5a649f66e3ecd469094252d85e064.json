{"remainingRequest":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/src/components/FlowForm.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/src/components/FlowForm.vue","mtime":1635747848179},{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/css-loader/dist/cjs.js","mtime":1627740750649},{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1634035958257},{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/postcss-loader/src/index.js","mtime":1627740750746},{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/cache-loader/dist/cjs.js","mtime":1627740747088},{"path":"/Users/sytruong/Hoiwa/demo-questionaire/demo-questionaire/node_modules/vue-loader/lib/index.js","mtime":1634035958257}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgpAaW1wb3J0ICcuLi9hc3NldHMvY3NzL2NvbW1vbi5jc3MnOwo="},{"version":3,"sources":["FlowForm.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAysBA","file":"FlowForm.vue","sourceRoot":"src/components","sourcesContent":["// Form template and logic\n\n<template>\n  <div class=\"vff\" :class=\"{'vff-not-standalone': !standalone, 'vff-is-mobile': isMobile, 'vff-is-ios': isIos}\">\n    <div class=\"f-container\">\n      <div class=\"f-form-wrap\">\n        <flow-form-question\n          ref=\"questions\"\n          v-for=\"(q, index) in questionList\"\n          v-bind:question=\"q\"\n          v-bind:language=\"language\"\n          v-bind:key=\"'q' + index\"\n          v-bind:active=\"q.index === activeQuestionIndex\"\n          v-model=\"q.answer\"\n          v-on:answer=\"onQuestionAnswered\"\n          v-bind:reverse=\"reverse\"\n        />\n\n        <slot></slot>\n\n        <!-- Complete/Submit screen slots -->   \n        <div v-if=\"isOnLastStep\" class=\"vff-animate f-fade-in-up field-submittype\">\n          <slot name=\"complete\">\n            <!-- Default content for the \"complete\" slot -->\n            <div class=\"f-section-wrap\">\n              <p>\n                <span class=\"fh2\">{{ language.thankYouText }}</span>\n              </p>\n            </div>\n          </slot>\n\n          <slot name=\"completeButton\">\n            <!-- Default content for the \"completeButton\" slot -->\n            <button \n              class=\"o-btn-action\"\n              ref=\"button\" \n              type=\"button\" \n              href=\"#\" \n              v-on:click.prevent=\"submit()\" \n              v-if=\"!submitted\"\n              v-bind:aria-label=\"language.ariaSubmitText\">\n                <span>{{ language.submitText }}</span>\n            </button>\n            <a \n              class=\"f-enter-desc\"\n              href=\"#\"\n              v-on:click.prevent=\"submit()\"\n              v-if=\"!submitted\"\n              v-html=\"language.formatString(language.pressEnter)\">\n            </a>\n            <p class=\"text-success\" v-if=\"submitted\">{{ language.successText }}</p>\n          </slot>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"vff-footer\">\n      <div class=\"footer-inner-wrap\">\n        <div v-if=\"progressbar\" class=\"f-progress\" v-bind:class=\"{'not-started': percentCompleted === 0, 'completed': percentCompleted === 100}\">\n          <div class=\"f-progress-bar\">\n            <div class=\"f-progress-bar-inner\" v-bind:style=\"'width: ' + percentCompleted + '%;'\"></div>\n          </div>\n          {{ language.percentCompleted.replace(':percent', percentCompleted) }}\n        </div>\n        <div v-if=\"navigation\" class=\"f-nav\">\n          <a\n            class=\"f-prev\"\n            href=\"#\"\n            v-bind:class=\"{'f-disabled': activeQuestionIndex === 0 || submitted}\"\n            v-on:click.prevent=\"goToPreviousQuestion()\"\n            role=\"button\"\n            v-bind:aria-label=\"language.ariaPrev\"\n          >\n            <svg\n              version=\"1.1\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n              xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n              x=\"0px\"\n              y=\"0px\"\n              width=\"42.333px\"\n              height=\"28.334px\"\n              viewBox=\"78.833 5.5 42.333 28.334\"\n              aria-hidden=\"true\"\n            >\n              <path\n                d=\"M82.039,31.971L100,11.442l17.959,20.529L120,30.187L101.02,8.492c-0.258-0.295-0.629-0.463-1.02-0.463c-0.39,0-0.764,0.168-1.02,0.463L80,30.187L82.039,31.971z\"\n              />\n            </svg>\n            <span class=\"f-nav-text\" aria-hidden=\"true\">{{ language.prev }}</span>\n          </a>\n          <a\n            class=\"f-next\"\n            href=\"#\"\n            v-bind:class=\"{'f-disabled': !isNextQuestionAvailable()}\"\n            v-on:click.prevent=\"goToNextQuestion()\"\n            role=\"button\"\n            v-bind:aria-label=\"language.ariaNext\"\n          >\n            <svg\n              version=\"1.1\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n              xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n              x=\"0px\"\n              y=\"0px\"\n              width=\"42.333px\"\n              height=\"28.334px\"\n              viewBox=\"78.833 5.5 42.333 28.334\"\n              aria-hidden=\"true\"\n            >\n              <path\n                d=\"M117.963,8.031l-17.961,20.529L82.042,8.031l-2.041,1.784l18.98,21.695c0.258,0.295,0.629,0.463,1.02,0.463c0.39,0,0.764-0.168,1.02-0.463l18.98-21.695L117.963,8.031z\"\n              />\n            </svg>\n            <span class=\"f-nav-text\" aria-hidden=\"true\">{{ language.next }}</span>\n          </a>\n        </div>\n        <div v-if=\"timer\" class=\"f-timer\">\n          <span>{{ formatTime(time) }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n  /*!\n    Copyright (c) 2020 - present, DITDOT Ltd. - MIT Licence\n    https://github.com/ditdot-dev/vue-flow-form\n    https://www.ditdot.hr/en\n  */\n\n  import FlowFormQuestion from './FlowFormQuestion.vue'\n  import QuestionModel, { ChoiceOption, LinkOption, QuestionType } from '../models/QuestionModel'\n  import LanguageModel from '../models/LanguageModel'\n  import { IsMobile } from '../mixins/IsMobile'\n\n  export default {\n    name: 'FlowForm',\n    components: {\n      FlowFormQuestion\n    },\n    \n    props: {\n      questions: {\n        type: Array,\n        validator: value => value.every(q => q instanceof QuestionModel)\n      }, \n      language: {\n        type: LanguageModel,\n        default: () => new LanguageModel()\n      },\n      progressbar: {\n        type: Boolean, \n        default: true\n      },\n      standalone: {\n        type: Boolean, \n        default: true\n      },\n      navigation: {\n        type: Boolean, \n        default: true\n      },\n      timer: {\n        type: Boolean,\n        default: false\n      },\n      timerStartStep: [String, Number],\n      timerStopStep: [String, Number]\n    },\n\n    mixins: [\n      IsMobile,\n    ],\n\n    data() {\n      return {\n        completed: false,\n        submitted: false,\n        activeQuestionIndex: 0,\n        questionList: [],\n        questionListActivePath: [],\n        reverse: false,\n        timerOn: false,\n        timerInterval: null,\n        time: 0\n      }\n    },\n\n    mounted() {\n      document.addEventListener('keydown', this.onKeyDownListener)\n      document.addEventListener('keyup', this.onKeyUpListener, true)\n      window.addEventListener('beforeunload', this.onBeforeUnload)\n\n      this.setQuestions()\n      this.checkTimer()\n    },\n\n    beforeDestroy() {\n      document.removeEventListener('keydown', this.onKeyDownListener)\n      document.removeEventListener('keyup', this.onKeyUpListener, true)\n      window.removeEventListener('beforeunload', this.onBeforeUnload)\n      \n      this.stopTimer()\n    },\n\n    computed: {\n      numActiveQuestions() {\n        return this.questionListActivePath.length\n      },\n\n      activeQuestion() {\n        return this.questionListActivePath[this.activeQuestionIndex]\n      },\n\n      activeQuestionId() {\n        const question = this.questionModels[this.activeQuestionIndex]\n\n        if (this.isOnLastStep) {\n          return '_submit'\n        }\n\n        if (question && question.id) {\n          return question.id\n        }\n\n        return null\n      },\n\n      numCompletedQuestions() {\n        let num = 0\n\n        this.questionListActivePath.forEach(question => {\n          if (question.answered) {\n            ++num\n          }\n        })\n\n        return num\n      },\n\n      percentCompleted() {\n        if (!this.numActiveQuestions) {\n          return 0\n        }\n\n        return Math.floor((this.numCompletedQuestions / this.numActiveQuestions) * 100)\n      },\n\n      isOnLastStep() {\n        return this.numActiveQuestions > 0 && this.activeQuestionIndex === this.questionListActivePath.length\n      }, \n\n      isOnTimerStartStep() {\n        if (this.activeQuestionId === this.timerStartStep) {\n          return true\n        }\n\n        if (!this.timerOn && !this.timerStartStep && this.activeQuestionIndex === 0) {\n          return true\n        }\n\n        return false\n      },\n\n      isOnTimerStopStep() {\n        if (this.submitted) {\n          return true\n        }\n        \n        if (this.activeQuestionId === this.timerStopStep) {\n          return true \n        }\n\n        return false\n      },\n\n      questionModels: {\n        cache: false,\n\n        get() {\n          if (this.questions && this.questions.length) {\n            return this.questions\n          }\n\n          const questions = []\n\n          if (!this.questions) {\n            const classMap = {\n              'options': ChoiceOption,\n              'descriptionLink': LinkOption\n            }\n\n            this\n              .$slots\n              .default\n              .filter(q => q.tag && q.tag.indexOf('Question') !== -1)\n              .forEach(q => {\n                const attrs = q.data.attrs\n                let model = new QuestionModel()\n\n                if (q.componentInstance.question !== null) {\n                  model = q.componentInstance.question\n                } \n\n                if (q.data.model) {\n                  model.answer = q.data.model.value\n                }\n\n                Object.keys(model).forEach(key => {\n                  if (attrs[key] !== undefined) {\n                    if (typeof model[key] === 'boolean') {\n                      model[key] = attrs[key] !== false\n                    } else if (key in classMap) {\n                      const\n                        classReference = classMap[key],\n                        options = []\n\n                      attrs[key].forEach(option => {\n                        const instance = new classReference()\n\n                        Object.keys(instance).forEach(instanceKey => {\n                          if (option[instanceKey] !== undefined) {\n                            instance[instanceKey] = option[instanceKey]\n                          }\n                        })\n\n                        options.push(instance)\n                      })\n\n                      model[key] = options\n                    } else {\n                      switch(key) {\n                        case 'type':\n                          if (Object.values(QuestionType).indexOf(attrs[key]) !== -1) {\n                            model[key] = attrs[key]\n                          } else {\n                            for (const questionTypeKey in QuestionType) {\n                              if (questionTypeKey.toLowerCase() === attrs[key].toLowerCase()) {\n                                model[key] = QuestionType[questionTypeKey]\n                                break\n                              }\n                            }\n                          }\n                          break\n\n                        default:\n                          model[key] = attrs[key]\n                          break\n                      }\n                    }\n                  }\n                })\n\n                q.componentInstance.question = model\n\n                model.resetOptions()\n\n                questions.push(model)\n              })\n          }\n\n          return questions\n        }\n      }\n    },\n\n    methods: {\n      /**\n       * Returns currently active question component (if any).\n       */\n      activeQuestionComponent() {\n        if (this.$refs.questions) {\n          return this.$refs.questions[this.activeQuestionIndex]\n        }\n\n        return null\n      },\n\n      setQuestions() {\n        this.setQuestionListActivePath()\n        this.setQuestionList()\n      },\n\n      /**\n       * This method goes through all questions and sets the ones\n       * that are in the current path (taking note of logic jumps)\n       */\n      setQuestionListActivePath() {\n        const questions = []\n\n        if (!this.questionModels.length) {\n          return\n        }\n\n        let\n          index = 0,\n          serialIndex = 0,\n          nextId\n\n        do {\n          let question = this.questionModels[index]\n\n          question.setIndex(serialIndex)\n          question.language = this.language\n\n          questions.push(question)\n\n          if (!question.jump) {\n            ++index\n          } else if (question.answered) {\n            nextId = question.getJumpId()\n            if (nextId) {\n              if (nextId === '_submit') {\n                index = this.questionModels.length\n              } else {\n                for (let i = 0; i < this.questionModels.length; i++) {\n                  if (this.questionModels[i].id === nextId) {\n                    index = i\n                    break\n                  }\n                }\n              }\n            } else {\n              ++index\n            }\n          } else {\n            index = this.questionModels.length\n          }\n\n          ++serialIndex\n        } while (index < this.questionModels.length)\n\n        this.questionListActivePath = questions\n      },\n\n      /**\n       * Sets the question list array\n       * (all questions up to, and including, the current one)\n       */\n      setQuestionList() {\n        const questions = []\n\n        for (let index = 0; index < this.questionListActivePath.length; index++) {\n          const question = this.questionListActivePath[index]\n\n          questions.push(question)\n\n          if (!question.answered) {\n            if (this.completed) {\n              // The \"completed\" status changed - user probably changed an\n              // already entered answer.\n              this.completed = false\n            }\n            break\n          }\n        }\n\n        this.questionList = questions\n      },\n\n      /**\n       * If we have any answered questions, notify user before leaving\n       * the page.\n       */\n      onBeforeUnload(event) {\n        if (this.activeQuestionIndex > 0 && !this.submitted) {\n          event.preventDefault()\n          event.returnValue = ''\n        }\n      },\n\n      /**\n       * Global key listeners, listen for Enter or Tab key events.\n       */\n      onKeyDownListener(e) {\n        if (e.key !== 'Tab' || this.submitted) {\n          return\n        }\n\n        if (e.shiftKey) {\n          e.stopPropagation()\n          e.preventDefault()\n\n          if (this.navigation) {\n            this.goToPreviousQuestion()\n          }\n        } else {\n          const q = this.activeQuestionComponent()\n\n          if (q.shouldFocus()) {\n            e.preventDefault()\n\n            q.focusField()\n          } else {\n            e.stopPropagation()\n\n            this.emitTab()\n            this.reverse = false\n          }\n        }\n      }, \n\n      onKeyUpListener(e) {\n        if (e.shiftKey || ['Tab', 'Enter'].indexOf(e.key) === -1 || this.submitted) {\n          return\n        }\n\n        const q = this.activeQuestionComponent()\n\n        if (e.key === 'Tab' && q.shouldFocus()) {\n          q.focusField()\n        } else {\n          if (e.key === 'Enter') {\n            this.emitEnter()\n          } \n\n          e.stopPropagation()\n          this.reverse = false\n        }\n      },\n\n      emitEnter() {\n        const q = this.activeQuestionComponent()\n\n        if (q) {\n          // Send enter event to the current question component\n          q.onEnter()\n        } else if (this.completed && this.isOnLastStep) {\n          // We're finished - submit form\n          this.submit()\n        }\n      },\n\n      emitTab() {\n        const q = this.activeQuestionComponent()\n\n        if (q) {\n          // Send tab event to the current question component\n          q.onTab()\n        } else {\n          this.emitEnter()\n        }\n      },\n\n      submit() {\n        this.emitSubmit()\n        this.submitted = true\n      },\n\n      emitComplete() {\n        this.$emit('complete', this.completed, this.questionList)\n      },\n\n      emitSubmit() {\n        this.$emit('submit', this.questionList)\n      },\n\n      /**\n       * Checks if we have another question and if we\n       * can jump to it.\n       */\n      isNextQuestionAvailable() {\n        if (this.submitted) {\n          return false\n        }\n\n        const q = this.activeQuestion\n        if (q && !q.required) {\n          return true\n        }\n\n        if (this.completed && !this.isOnLastStep) {\n          return true\n        }\n   \n        return this.activeQuestionIndex < this.questionList.length - 1\n      },\n\n      /**\n       * Triggered by the \"answer\" event in the Question component\n       */\n      onQuestionAnswered(question) {\n        if (question.isValid()) {\n          this.$emit('answer', question.question)\n\n          if (this.activeQuestionIndex < this.questionListActivePath.length) {\n            ++this.activeQuestionIndex\n          }\n         \n          this.$nextTick(() => {\n            this.setQuestions()\n            this.checkTimer()\n            // Nested $nextTick so we're 100% sure that setQuestions\n            // actually updated the question array\n            this.$nextTick(() => {\n              const q = this.activeQuestionComponent()\n\n              if (q) {\n                q.focusField()\n                this.activeQuestionIndex = q.question.index\n              } else if (this.isOnLastStep) {\n                // No more questions left - set \"completed\" to true\n                this.completed = true\n                this.activeQuestionIndex = this.questionListActivePath.length\n                \n                this.$refs.button && this.$refs.button.focus()\n              }\n\n              this.$emit('step', this.activeQuestionId, this.activeQuestion)\n            })\n          })\n        } else if (this.completed) {\n          this.completed = false\n        }\n      },\n\n      /**\n       * Jumps to previous question.\n       */\n      goToPreviousQuestion() {\n        this.blurFocus()\n    \n        if (this.activeQuestionIndex > 0 && !this.submitted) {\n          if (this.isOnTimerStopStep) {\n            this.startTimer()\n          }\n\n          --this.activeQuestionIndex\n\n          this.reverse = true\n\n          this.checkTimer()\n        }\n      },\n\n      /**\n       * Jumps to next question.\n       */\n      goToNextQuestion() {\n        this.blurFocus()\n        if (this.isNextQuestionAvailable()) {\n          this.emitEnter()\n        }\n\n        this.reverse = false\n      },\n\n      /**\n       * Removes focus from the currently focused DOM element.\n       */\n      blurFocus() {\n        document.activeElement && document.activeElement.blur && document.activeElement.blur()\n      },\n\n      checkTimer() {\n        if (this.timer) {\n          if (this.isOnTimerStartStep) {\n            this.startTimer()\n          } else if (this.isOnTimerStopStep) {\n            this.stopTimer()\n          }\n        }\n      },\n\n      startTimer() {\n        if (this.timer && !this.timerOn) {\n          this.timerInterval = setInterval(this.incrementTime, 1000)\n          this.timerOn = true\n        }\n      },\n\n      stopTimer() {\n        if (this.timerOn) {\n          clearInterval(this.timerInterval)\n        }\n\n        this.timerOn = false\n      },\n\n      incrementTime() {\n        ++this.time\n        \n        this.$emit('timer', this.time, this.formatTime(this.time))\n      },\n\n      formatTime(seconds) {\n        let\n          startIndex = 14,\n          length = 5\n            \n        if (seconds >= 60 * 60) {\n          startIndex = 11\n          length = 8\n        }\n\n        return new Date(1000 * seconds).toISOString().substr(startIndex, length)\n      }\n    },\n\n    watch: {\n      completed() {\n        this.emitComplete()\n      },\n      \n      submitted() {\n        this.stopTimer()\n      }\n    }\n  }\n</script>\n\n<style lang=\"css\">\n  @import '../assets/css/common.css';\n</style>"]}]}